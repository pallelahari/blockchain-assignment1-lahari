BLOCKCHAIN ASSIGNMENT 1
HOW TO RUN:
1. Clone or download the repo
2. Open terminal in the folder
3. Run:
node blockchain.js
<img width="816" height="481" alt="Screenshot from 2025-09-06 22-50-38" src="https://github.com/user-attachments/assets/eab8243d-f0f1-4ae0-9978-aa6788dc3405" />

<img width="822" height="482" alt="Screenshot from 2025-09-06 22-58-26" src="https://github.com/user-attachments/assets/f938f174-572c-4d8e-850e-e7b8eff0c23d" />
<img width="822" height="482" alt="Screenshot from 2025-09-06 22-58-41" src="https://github.com/user-attachments/assets/c0901adb-74c6-4bab-a2e7-647c5fe2f6c7" />
<img width="822" height="482" alt="Screenshot from 2025-09-06 22-58-51" src="https://github.com/user-attachments/assets/1e7002c3-5e34-400b-af9b-120fa802429c" />
<img width="828" height="486" alt="Screenshot from 2025-09-06 22-59-05" src="https://github.com/user-attachments/assets/5221395b-3d71-4c32-a4ab-bd9bd2f77fd4" />

REFLECTION:
Hashing ensures that any small change in block data results in a completely different hash, making data tampering easily detectable. This enforces immutability in the blockchain â€” once data is added and mined, changing it breaks the chain.
Proof-of-Work makes it computationally expensive to alter any block because you'd need to re-mine all subsequent blocks to restore the chain. This acts as a deterrent against tampering and helps reach consensus in decentralized systems.
It was surprising how small code changes (like modifying a number) could completely invalidate the chain. Also, how expensive mining gets as difficulty increases was a good insight into blockchain scalability issues.
